Metadata-Version: 2.4
Name: IGCAnalysis
Version: 1.4.0
Summary: MY IGC LIB
Author-email: Helmut Kindl <hkindl@gmail.com>
License: MIT License
        
        Copyright (c) 2024 birne67
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        
Project-URL: Homepage, https://github.com/birne67/IGCAnalysis
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: license-file

howto â€” Build & use your local Python library (privates Projekt)

Kurz
- Du arbeitest bereits in deiner Entwicklungsumgebung â†’ kein extra venv in dieser Anleitung.
- Keine VerÃ¶ffentlichung zu PyPI (privates Projekt). Stattdessen optional GitHub Releases fÃ¼r Artefakte.
- Editable mode (-e) erklÃ¤rt.

1) Update Build-Tools (in deinem aktiven env)
```bash
python -m pip install --upgrade pip build wheel pytest
```

2) Tests ausfÃ¼hren (vor jedem Build)
```bash
python -m pytest -q
```

3) Paket bauen (modern, PEP 517-konform)
```bash
cd MyPythonLibrary/IGCAnalysis
python -m build
# Ausgabe: dist/*.whl und dist/*.tar.gz
```

4) Version updaten & taggen
- Pflege die Version an einer einzigen Stelle (siehe Kapitel "Single source of truth" weiter unten).
```bash
cd MyPythonLibrary/IGCAnalysis
python3 tools/set_version.py 1.4.0
git add .
git commit -m "Version 1.4"
git tag v1.4
git push origin main --follow-tags
```

5) Lokale Entwicklung (editable mode)
```bash
# aus einem lokal geklonten Repo
pip install -e .
```
- Was -e bewirkt:
  - pip legt einen Verweis auf dein Quellverzeichnis an (keine Kopie ins siteâ€‘packages).
  - Ã„nderungen am Code sind sofort importierbar â€” du musst nicht nach jeder Ã„nderung neu installieren.
  - Ideal fÃ¼r Entwicklung, Tests und Debugging. AbhÃ¤ngigkeiten werden in deiner aktiven Umgebung installiert.
  - Hinweis: Editable direkt aus GitHub per VCS funktioniert nur, wenn pip und dein Backend PEP 660 (editable wheels) unterstÃ¼tzen. Falls Probleme, lokal klonen + pip install -e .

6) Installieren aus built wheel (fÃ¼r Nutzung ohne Entwicklung)
```bash
pip install dist/YourPackage-1.3-py3-none-any.whl
```

7) GitHub Releases (ohne PyPI) â€” optional automatisieren
- Du kannst Tags pushen und eine GitHub Actions Workflow konfigurieren, die baut und die Artefakte als Releaseâ€‘Assets hochlÃ¤dt. Damit brauchst du kein PyPI / twine.
- Installieren aus Release (client):
```bash
pip install https://github.com/<owner>/<repo>/releases/download/v1.3/YourPackage-1.3-py3-none-any.whl
```

Single source of truth â€” Versionen korrekt verwalten (ohne setuptools_scm)
- Problem: In deinem Projekt standen Versionen mehrfach (pyproject.toml und setup.py). Das kann zu Inkonsistenzen fÃ¼hren.
- Empfehlung 1 (einfach): Verwende nur `pyproject.toml` als Metadatenâ€‘Quelle und entferne die statische `version` aus `setup.py` (oder lÃ¶sche `setup.py` ganz, wenn nicht benÃ¶tigt). Das verhindert divergierende Versionen.
- Empfehlung 2 (falls du die Version zur Laufzeit brauchst): Lege zusÃ¤tzlich in deinem Paket eine `__version__`â€‘Variable in `yourpackage/__init__.py` an und pflege die Version dort manuell. Dann halte `pyproject.toml` und `__version__` synchron â€” z. B. mit einem kleinen Skript oder einem preâ€‘release Schritt, der die Version in beide Dateien schreibt.

Beispiel synchronisationsskript (einfacher Weg)
```python
# tools/set_version.py
"""Small helper to set version in both pyproject.toml and package __init__.py
Usage: python tools/set_version.py 1.3
"""
import sys
from pathlib import Path
v = sys.argv[1]
py = Path('pyproject.toml')
pkginit = Path('IGCAnalysis/__init__.py')
txt = py.read_text()
txt = txt.replace('\nversion = "' + next(x for x in txt.splitlines() if x.strip().startswith('version'))[9:].strip('"'), f'\nversion = "{v}"')
py.write_text(txt)
init = pkginit.read_text()
if "__version__" in init:
    init = '\n'.join([l if not l.strip().startswith('__version__') else f"__version__ = \"{v}\"" for l in init.splitlines()])
else:
    init = f"__version__ = \"{v}\"\n" + init
pkginit.write_text(init)
```
- Hinweis: Das Skript ist minimal und kann an dein Projektlayout angepasst werden. Alternativ kannst du einfach nur `pyproject.toml` als Versionquelle nehmen und `setup.py` entfernen.

------------------------------------------------------------------------------------------------------------------------------------
Perfekt â€” ich habe das Projekt aufgerÃ¤umt und modernisiert:

- Entfernt: legacy `setup.py` (nicht mehr nÃ¶tig). âœ…
- Single source: `pyproject.toml` ist jetzt die einzige Metadatenâ€‘Quelle (Version ist aktuell auf 1.3.0). âœ…
- Paketâ€‘Version: `IGCAnalysis/__init__.py` enthÃ¤lt nun `__version__ = "1.3.0"` und ist synchron zur `pyproject.toml`. âœ…
- Neue Hilfsmittel: `tools/set_version.py` (kleines Script, um Versionen synchron zu halten). âœ…
- CI: Eine GitHub Actions Workflow wurde ergÃ¤nzt (`.github/workflows/release-assets.yml`) â€” sie erstellt Builds bei Tagâ€‘Push und hÃ¤ngt alle Dateien aus `dist/` an den Release. âœ…
- HowTo: `src/WebApp/howto.md` (bzw 'README.md') wurde angelegt/aktualisiert mit klarer Anleitung (kein venv, -e erklÃ¤rt, kein PyPI nÃ¶tig). âœ…

Hinweis: Ich habe alte Build/egg-infoâ€‘Artefakte bereinigt; `dist/` enthÃ¤lt ggf. Ã¤ltere Artefakte â€” sag Bescheid, wenn ich auch diese lÃ¶schen soll.


======= Doppelt! =========
Perfekt â€” ich habe das Projekt aufgerÃ¤umt und alles modernisiert. Kurz: ich habe das Legacyâ€‘Zeug entfernt (inkl. setup.py), pyproject.toml zur einzigen Metadatenâ€‘Quelle gemacht, die Paketâ€‘Version auf 1.3.0 synchronisiert und deine Howâ€‘To + Workflow + Syncâ€‘Script ergÃ¤nzt. 

Was ich getan habe âœ…

Entfernt: legacy setup.py (nicht mehr notwendig).
Synchronisiert: Version unter pyproject.toml â†â†’ __init__.py auf 1.3.0.
HinzugefÃ¼gt:
howto.md â€” aktualisierte, klare Anleitung (kein venv, -e erklÃ¤rt, kein PyPI).
release-assets.yml â€” GitHub Actions: build â†’ Releaseâ€‘Assets bei Tag Push (kein PyPI).
set_version.py â€” kleines Helferâ€‘Script zum Synchronisieren von Versionen.
AufgerÃ¤umt: entfernt build/ und IGCAnalysis.egg-info/. Belassen: dist/ (alte Artefakte â€” mÃ¶chtest du diese auch lÃ¶schen?).
Wichtige Befehle & Hinweise ğŸ”§

Version setzen (lokal â€” das Script habe ich angelegt):

    cd MyPythonLibrary/IGCAnalysis
    python3 tools/set_version.py 1.3.0

(Das Ã¤ndert pyproject.toml und __init__.py synchron.)

Wie Du den GitHubâ€‘Releaseâ€‘Workflow nutzt (kein PyPI nÃ¶tig):
Tag erzeugen:
    git tag v1.3.0
    git push origin v1.3.0

GitHub Actions baut das Paket und hÃ¤ngt alle dist/* Dateien an den Release an.
Clientâ€‘Installation aus Release:
    pip install https://github.com/<owner>/<repo>/releases/download/v1.3.0/IGCAnalysis-1.3.0-py3-none-any.whl

Was bedeutet pip install -e . genau?

Es installiert keinen Kopieâ€‘Ordner im siteâ€‘packages, sondern erstellt eine VerknÃ¼pfung auf dein Quellverzeichnis. Du Ã¤nderst Code â†’ Ã„nderungen sind sofort wirksam beim Import. Super fÃ¼r Entwicklung und Debugging.


=======================================

---
## ErklÃ¤rung zu `.github/workflows/release-assets.yml`

Kurzfassung (auf einen Blick)

- Die Datei `.github/workflows/release-assets.yml` wird automatisch von GitHub Actions ausgefÃ¼hrt, wenn ein Tag gepusht wird, der zum Muster passt (hier: `v*.*.*` â†’ z. B. `v1.3.0`).
- Der Workflow baut dein Paket mit `python -m build` in einer frischen GitHubâ€‘Runnerâ€‘Umgebung und lÃ¤dt die erzeugten Artefakte `dist/*` als Releaseâ€‘Assets an den GitHub Release (kein PyPI nÃ¶tig).
- Du brauchst in der Regel nur ein Tag zu pushen â€” GitHub Actions Ã¼bernimmt alles. Optional kannst du den Workflow auch manuell auslÃ¶sen.

Detaillierte ErklÃ¤rung â€“ was der Workflow genau macht

1) Trigger
- Aktuell wird der Workflow bei Tagâ€‘Pushes ausgelÃ¶st:
```yaml
on:
    push:
        tags:
            - 'v*.*.*'
```
â†’ er startet automatisch, sobald z. B. `git tag v1.3.0` und `git push origin v1.3.0` ausgefÃ¼hrt werden.

2) Schritte im Workflow
- `actions/checkout@v4` â€” zieht den Quellcode in den Runner.
- `actions/setup-python@v4` â€” richtet die Pythonâ€‘Umgebung ein (hier: 3.10).
- Install build tools â€” `python -m pip install --upgrade pip build`.
- Build â€” `python -m build` erzeugt sdist und wheel in `dist/` im Runner.
- `softprops/action-gh-release@v1` (mit `files: dist/*`) erzeugt bzw. ergÃ¤nzt den zugehÃ¶rigen GitHub Release und hÃ¤ngt alle Dateien aus `dist/` als Releaseâ€‘Assets an.

3) Auth & Rechte
- `GITHUB_TOKEN` wird von GitHub Actions automatisch bereitgestellt und hat die benÃ¶tigten Rechte, um Releases zu erstellen und Assets hochzuladen â€” keine zusÃ¤tzlichen Secrets notwendig.

4) Ergebnis
- Dein Repository erhÃ¤lt auf GitHub einen Release mit den Buildâ€‘Artefakten (`.whl`, `.tar.gz`). Diese Artefakte kannst du herunterladen oder per `pip install <release-url>` installieren.

Praktische Beispiele â€” so lÃ¶st du den Workflow aus

Automatisch (Standard):
```bash
# Stelle sicher, dass pyproject.toml die gewÃ¼nschte Version enthÃ¤lt
git add .
git commit -m "chore: bump to 1.3.0"
git tag v1.3.0
git push origin v1.3.0
```
â†’ GitHub Actions startet automatisch und erzeugt Release + Assets.

Manuell (optional):
- Wenn du den Workflow manuell machen mÃ¶chtest, kannst du `workflow_dispatch:` als weiteren Trigger ergÃ¤nzen:
```yaml
on:
    push:
        tags:
            - 'v*.*.*'
    workflow_dispatch:
```
- Dann kannst du den Workflow im GitHub UI â€Run workflowâ€œ klicken oder per GitHub CLI starten:
```bash
gh workflow run release-assets.yml --repo birne67/IGCAnalysis
```

Debugging & hÃ¤ufige Fehler
- Logs Ã¼berprÃ¼fen: Repo â†’ Actions â†’ Run â†’ Schrittâ€‘Logs (Build / Upload).
- Buildâ€‘Fehler: meist fehlende Systemâ€‘AbhÃ¤ngigkeiten im Runner (ggf. aptâ€‘install in Workflow ergÃ¤nzen).
- Leere `dist/`: prÃ¼fe, ob `python -m build` erfolgreich war.
- Uploadâ€‘Fehler: prÃ¼fe dass `GITHUB_TOKEN` korrekt vorhanden ist (normalerweise automatisch verfÃ¼gbar).

Tipps & Anpassungen
- Lade nur bestimmte Artefakte hoch: `files: dist/*.whl` statt `dist/*`.
- Multiâ€‘Versionâ€‘Build: benutze matrix jobs, falls du wheels fÃ¼r mehrere Pythonâ€‘Versionen brauchst.
- Releaseâ€‘Notizen: du kannst automatisch Changelogs erzeugen oder `github.ref_name` als Releaseâ€‘Titel verwenden.

Empfehlung
- Teste zuerst mit einem kleinen Tag (z. B. `v1.3.0`) und prÃ¼fe die Actionâ€‘Logs; wenn alles sauber lÃ¤uft, ist der Releaseâ€‘Workflow zuverlÃ¤ssig und erfordert kaum Wartung.
